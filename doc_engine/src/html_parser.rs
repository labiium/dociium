//! Very–lightweight fallback parser that converts a docs.rs HTML page
//! to a synthetic `rustdoc_types::Crate` containing **only** the crate
//! root item.  It is **not** a full HTML → JSON converter – it merely
//! lets the rest of the pipeline keep working when
//! `rustdoc.json` is unavailable.

use anyhow::Result;
use rustdoc_types::{
    Crate as RustdocCrate, Id, Item, ItemEnum, ItemKind, ItemSummary, Module, Visibility,
    FORMAT_VERSION,
};
use scraper::{ElementRef, Html, Selector};
use std::collections::HashMap;
/// Parse a docs.rs HTML page and build a minimal [`RustdocCrate`].
///
/// * `html`       – raw HTML from docs.rs
/// * `crate_name` – canonical name of the crate
/// * `version`    – crate version as string
///
/// The returned value contains **exactly one** item – the crate root –
/// with its `docs` field filled with the rendered Markdown extracted
/// from the page.
///
/// # ⚠ Limitations
///
/// • Child items (modules, structs, …) are NOT included.
/// • Source‐code spans are NOT available.
/// • Because of the above only a handful of high-level engine methods
///   will work with the synthetic data (e.g. `get_item_doc` for the
///   crate itself).
pub fn parse_crate_root_from_html(
    html: &str,
    crate_name: &str,
    version: &str,
) -> Result<RustdocCrate> {
    let document = Html::parse_document(html);

    // ──────────────────────────────────────────────────────────────
    // 1.  Locate the *main* docblock that contains the top-level
    //     crate documentation.  Over Rust versions the exact nesting
    //     changed, so we test several selectors.
    // ──────────────────────────────────────────────────────────────
    let selectors = &[
        // Current rustdoc (2024-xx)
        Selector::parse("section#main div.docblock").unwrap(),
        // Older rustdoc (<= 1.60)
        Selector::parse("div#main div.docblock").unwrap(),
        // Fallback – any docblock on the page
        Selector::parse("div.docblock").unwrap(),
    ];

    let docblock: Option<ElementRef<'_>> =
        selectors.iter().find_map(|sel| document.select(sel).next());

    let doc_markdown = docblock
        .map(extract_markdown_from_docblock)
        .transpose()?
        .unwrap_or_else(|| {
            // Empty but we still want to return a crate
            format!(
                "_Autogenerated stub – no documentation text found for crate_ **{}**",
                crate_name
            )
        });

    // ──────────────────────────────────────────────────────────────
    // 2.  rustdoc > 1.68 embeds a meta tag with the JSON format
    //     version.  Keep it if we can, otherwise fall back to the
    //     compile-time constant exported by rustdoc-types.
    // ──────────────────────────────────────────────────────────────
    let format_version = document
        .select(&Selector::parse("meta[name=rustdoc-format-version]").unwrap())
        .next()
        .and_then(|m| m.value().attr("content"))
        .and_then(|v| v.parse::<u32>().ok())
        .unwrap_or(FORMAT_VERSION);

    // ──────────────────────────────────────────────────────────────
    // 3.  Build a synthetic rustdoc JSON structure.
    // ──────────────────────────────────────────────────────────────
    let root_id = Id("0".to_string());

    let root_item = Item {
        id: root_id.clone(),
        crate_id: 0,
        name: Some(crate_name.to_owned()),
        span: None,
        visibility: Visibility::Public,
        docs: Some(doc_markdown),
        links: HashMap::new(),
        attrs: Vec::new(),
        deprecation: None,
        inner: ItemEnum::Module(Module {
            is_crate: true,
            items: Vec::new(),
            is_stripped: false,
        }),
    };

    let mut index = HashMap::new();
    index.insert(root_id.clone(), root_item);

    let mut paths = HashMap::new();
    paths.insert(
        root_id.clone(),
        ItemSummary {
            crate_id: 0,
            path: vec![crate_name.to_owned()],
            kind: ItemKind::Module,
        },
    );

    Ok(RustdocCrate {
        root: root_id,
        crate_version: Some(version.to_string()),
        includes_private: false,
        index,
        paths,
        external_crates: HashMap::new(),
        format_version,
    })
}

/// Extract Markdown text from a `<div class="docblock">` node.
///
/// The strategy is simple but keeps headings and code fences intact:
///
/// 1.  For every immediate child element:
///     • `<p>` → keep its inner text with a blank line after it.
///     • `<pre><code>` → wrap in triple-backtick fences.
///     • Headings `<hN>` → convert to Markdown `#` syntax.
/// 2.  Unknown nodes fall back to plain concatenation.
///
/// We do **not** attempt full HTML → Markdown fidelity because this file
/// is only a fallback and clients are advised to fetch the HTML directly
/// if they need richer content.
fn extract_markdown_from_docblock(node: ElementRef<'_>) -> Result<String> {
    use scraper::node::Node;
    use std::fmt::Write;

    let mut out = String::new();

    for child in node.children() {
        match child.value() {
            Node::Element(el) if el.name() == "p" => {
                let text = ElementRef::wrap(child)
                    .unwrap()
                    .text()
                    .collect::<Vec<_>>()
                    .join(" ");
                writeln!(out, "{}\n", text.trim())?;
            }
            Node::Element(el) if el.name() == "pre" => {
                // Look for <code> child or just use the plain text
                let code = ElementRef::wrap(child)
                    .unwrap()
                    .text()
                    .collect::<Vec<_>>()
                    .join("\n");
                writeln!(out, "```rust\n{}\n```\n", code.trim_end())?;
            }
            Node::Element(el) if matches!(el.name(), "h1" | "h2" | "h3" | "h4" | "h5" | "h6") => {
                let level = match &el.name()[1..] {
                    "1" => "#",
                    "2" => "##",
                    "3" => "###",
                    "4" => "####",
                    "5" => "#####",
                    _ => "######",
                };
                let text = ElementRef::wrap(child)
                    .unwrap()
                    .text()
                    .collect::<Vec<_>>()
                    .join(" ");
                writeln!(out, "{} {}\n", level, text.trim())?;
            }
            _ => {
                // Fallback: plain text
                if let Some(el) = ElementRef::wrap(child) {
                    let text = el.text().collect::<Vec<_>>().join(" ");
                    if !text.trim().is_empty() {
                        writeln!(out, "{}\n", text.trim())?;
                    }
                }
            }
        }
    }

    Ok(out.trim_end().to_owned())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn parses_current_docs_rs_layout() {
        use crate::fetcher::Fetcher;

        // Fetch real HTML for a small crate so the test remains fast.
        let html = Fetcher::new()
            .fetch_crate_html_from_docs_rs("itoa", "1.0.11")
            .await
            .expect("network request failed")
            .expect("docs.rs returned 404");

        let krate =
            parse_crate_root_from_html(&html, "itoa", "1.0.11").expect("HTML parsing failed");

        // The crate root must be present and contain a meaningful sentence
        let root_item = krate.index.get(&krate.root).expect("root item missing");
        let docs = root_item.docs.as_ref().expect("crate root has no docs");

        assert!(
            docs.contains("integer") && docs.contains("primitives"),
            "unexpected doc content: {docs:?}"
        );
        // Ensure the rustdoc format version was preserved / parsed
        assert!(krate.format_version >= rustdoc_types::FORMAT_VERSION);
    }
}
