use anyhow::Result;
use index_core::{IndexCore, QueryType, SymbolIndex, SymbolKind, SymbolSearchOptions};
use rustdoc_types::Crate as RustdocCrate;
use std::fs::File;
use std::io::BufReader;
use std::path::PathBuf;
use tempfile::tempdir;

// Helper to load pre-generated rustdoc JSON for a fixture crate
// In a real test setup, this JSON would be generated by a build script or a test setup function.
fn load_rustdoc_fixture(name: &str) -> Result<RustdocCrate> {
    let mut path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    path.push("tests/fixtures");
    // Convention: tests/fixtures/mini_math.json (for mini_math crate)
    path.push(format!("{}.json", name));

    if !path.exists() {
        // Attempt to generate if it doesn't exist (conceptual, won't run in this environment)
        // This is a placeholder for what a test runner or build script might do.
        // generate_fixture_json_if_needed(name)?;
        return Err(anyhow::anyhow!(
            "Fixture JSON not found: {:?}. Please pre-generate it.",
            path
        ));
    }

    let file = File::open(&path)?;
    let reader = BufReader::new(file);
    let krate: RustdocCrate = serde_json::from_reader(reader)?;
    Ok(krate)
}

// Placeholder for a function that would run `cargo rustdoc`
// fn generate_fixture_json_if_needed(name: &str) -> Result<()> {
//     let mut fixture_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
//     fixture_path.push("tests/fixtures");
//     fixture_path.push(name); // e.g., mini_math
//     let output_json_path = fixture_path.with_extension("json");
//     if output_json_path.exists() { return Ok(()); }
//     // ... logic to run cargo rustdoc ...
//     Ok(())
// }

#[tokio::test]
async fn test_mini_math_indexing_and_term_search() -> Result<()> {
    let temp_dir = tempdir()?;
    let index_core = IndexCore::new(temp_dir.path())?;
    let mini_math_rustdoc = load_rustdoc_fixture("mini_math")?;

    let crate_version = mini_math_rustdoc
        .crate_version
        .as_deref()
        .unwrap_or("0.1.0");
    let symbol_index_path = index_core
        .symbol_index_base_path()
        .join(format!("mini_math@{}", crate_version));
    let symbol_index = SymbolIndex::new(symbol_index_path);

    symbol_index.add_crate(&mini_math_rustdoc).await?;

    // Test: Search for "Point" struct
    let options = SymbolSearchOptions {
        query: "Point".to_string(),
        query_type: QueryType::Term,
        limit: 5,
        ..Default::default()
    };
    let results = symbol_index.search(&options)?;

    assert!(!results.is_empty(), "Should find 'Point' struct");
    let point_res = results
        .iter()
        .find(|r| r.path == "mini_math::Point" || r.path == "Point"); // Path might be crate-relative from indexer
    assert!(
        point_res.is_some(),
        "Specific 'Point' struct not found in results: {:?}",
        results
    );
    if let Some(p) = point_res {
        assert!(matches!(p.kind, SymbolKind::Struct));
        assert!(p
            .doc_summary
            .as_deref()
            .unwrap_or("")
            .contains("struct representing a point"));
    }

    // Test: Search for "add" function
    let options_fn = SymbolSearchOptions {
        query: "add".to_string(),
        query_type: QueryType::Term,
        limit: 5,
        kinds: Some(vec![SymbolKind::Function]),
        ..Default::default()
    };
    let results_fn = symbol_index.search(&options_fn)?;
    assert!(!results_fn.is_empty(), "Should find 'add' function");
    let add_res = results_fn
        .iter()
        .find(|r| r.path == "mini_math::add" || r.path == "add");
    assert!(
        add_res.is_some(),
        "Specific 'add' function not found in results: {:?}",
        results_fn
    );
    if let Some(f) = add_res {
        assert!(matches!(f.kind, SymbolKind::Function));
    }

    // Test: Search for "PI" constant
    let options_const = SymbolSearchOptions {
        query: "PI".to_string(),
        query_type: QueryType::Exact, // Exact match for constant name
        limit: 1,
        kinds: Some(vec![SymbolKind::Const]),
        ..Default::default()
    };
    let results_const = symbol_index.search(&options_const)?;
    assert_eq!(results_const.len(), 1, "Should find 'PI' constant");
    if let Some(c) = results_const.first() {
        assert!(matches!(c.kind, SymbolKind::Const));
        assert!(c.path.ends_with("PI"));
    }

    Ok(())
}

#[tokio::test]
async fn test_mini_math_prefix_search() -> Result<()> {
    let temp_dir = tempdir()?;
    let index_core = IndexCore::new(temp_dir.path())?;
    let mini_math_rustdoc = load_rustdoc_fixture("mini_math")?;
    let crate_version = mini_math_rustdoc
        .crate_version
        .as_deref()
        .unwrap_or("0.1.0");
    let symbol_index_path = index_core
        .symbol_index_base_path()
        .join(format!("mini_math@{}", crate_version));
    let symbol_index = SymbolIndex::new(symbol_index_path);
    symbol_index.add_crate(&mini_math_rustdoc).await?;

    let options = SymbolSearchOptions {
        query: "Point".to_string(), // Search for things starting with "Point"
        query_type: QueryType::Prefix,
        limit: 5,
        ..Default::default()
    };
    let results = symbol_index.search(&options)?;

    let point_found = results.iter().any(|r| r.path.ends_with("Point"));
    let pointf32_found = results.iter().any(|r| r.path.ends_with("PointF32"));
    let pointgeneric_found = results.iter().any(|r| r.path.ends_with("PointGeneric"));

    assert!(point_found, "Prefix search should find 'Point'");
    assert!(pointf32_found, "Prefix search should find 'PointF32'");
    assert!(
        pointgeneric_found,
        "Prefix search should find 'PointGeneric'"
    );

    Ok(())
}

#[tokio::test]
async fn test_mini_math_fuzzy_search() -> Result<()> {
    let temp_dir = tempdir()?;
    let index_core = IndexCore::new(temp_dir.path())?;
    let mini_math_rustdoc = load_rustdoc_fixture("mini_math")?;
    let crate_version = mini_math_rustdoc
        .crate_version
        .as_deref()
        .unwrap_or("0.1.0");
    let symbol_index_path = index_core
        .symbol_index_base_path()
        .join(format!("mini_math@{}", crate_version));
    let symbol_index = SymbolIndex::new(symbol_index_path);
    symbol_index.add_crate(&mini_math_rustdoc).await?;

    let options = SymbolSearchOptions {
        query: "Piont".to_string(), // Misspelled "Point"
        query_type: QueryType::Fuzzy,
        fuzzy_distance: Some(1),
        limit: 5,
        kinds: Some(vec![SymbolKind::Struct]),
        ..Default::default()
    };
    let results = symbol_index.search(&options)?;

    let point_found = results
        .iter()
        .any(|r| r.path.ends_with("Point") && matches!(r.kind, SymbolKind::Struct));
    assert!(
        point_found,
        "Fuzzy search for 'Piont' should find 'Point' struct. Results: {:?}",
        results
    );

    Ok(())
}

// TODO: Add tests for filtering by module_path, visibility
// TODO: Add tests for scoring/boosting if implemented
// TODO: Add tests for RocksDB persistence of metadata (if IndexCore stores any directly)
// TODO: Add tests for TraitImplIndex using mini_math

use proptest::prelude::*;
proptest! {
    #[test]
    fn proptest_symbol_search_does_not_panic(
        query in "\\PC*", // Arbitrary strings, \PC* for unicode characters
        limit in 0..100usize,
        offset in 0..50usize,
        fuzzy_dist in 0..3u8,
        query_type_idx in 0..4 // To select QueryType
    ) {
        // This test needs an initialized index to run against.
        // For simplicity, it runs against an empty index or a pre-loaded mini_math.
        // The primary goal here is to check for panics, not correctness of results with random inputs.

        let temp_dir = tempdir().unwrap();
        let index_core = IndexCore::new(temp_dir.path()).unwrap();

        // Minimal setup: create an empty index for mini_math schema
        let symbol_index_path = index_core.symbol_index_base_path().join("proptest_dummy@0.1.0");
        std::fs::create_dir_all(&symbol_index_path).unwrap();
        SymbolIndex::open_or_create(&symbol_index_path).unwrap(); // Ensure schema is init'd
        let symbol_index = SymbolIndex::new(symbol_index_path);


        let query_type = match query_type_idx {
            0 => QueryType::Exact,
            1 => QueryType::Prefix,
            2 => QueryType::Fuzzy,
            _ => QueryType::Term,
        };

        let options = SymbolSearchOptions {
            query: query.clone(), // query can be reused by proptest if not cloned
            query_type,
            fuzzy_distance: Some(fuzzy_dist),
            limit,
            offset,
            ..Default::default()
        };

        // We just want to ensure this doesn't panic.
        // The result itself (Ok/Err) can vary wildly with random inputs.
        let _ = symbol_index.search(&options);
    }
}
