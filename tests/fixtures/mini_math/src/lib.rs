//! # Mini Math Crate
//!
//! A small example crate for testing documentation indexing and searching.
//! It includes various Rust items.

/// A public constant representing PI.
pub const PI: f64 = 3.1415926535;

/// A private constant, should not typically be indexed by default.
#[allow(dead_code)]
const EULER_MASCHERONI: f64 = 0.5772156649;

/// A simple struct representing a point in 2D space.
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Point {
    /// The x-coordinate of the point.
    pub x: i32,
    /// The y-coordinate of the point.
    pub y: i32,
}

impl Point {
    /// Creates a new Point.
    ///
    /// # Examples
    /// ```
    /// use mini_math::Point;
    /// let p = Point::new(10, 20);
    /// assert_eq!(p.x, 10);
    /// ```
    pub fn new(x: i32, y: i32) -> Self {
        Point { x, y }
    }

    /// Calculates the Manhattan distance from the origin.
    fn distance_from_origin(&self) -> i32 { // Private method
        self.x.abs() + self.y.abs()
    }
}

/// An enum representing different geometric shapes.
pub enum Shape {
    /// A circle with a given radius.
    Circle(f64),
    /// A rectangle with a given width and height.
    Rectangle(f64, f64),
}

/// A trait for calculating the area of a shape.
pub trait Area {
    /// Calculates the area.
    fn calculate_area(&self) -> f64;
}

impl Area for Shape {
    fn calculate_area(&self) -> f64 {
        match self {
            Shape::Circle(radius) => PI * radius * radius,
            Shape::Rectangle(width, height) => width * height,
        }
    }
}

/// Adds two numbers.
///
/// This function is very basic.
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

/// Subtracts two numbers.
///
/// Documented but perhaps less used.
#[doc(hidden)] // Example of a documented but hidden item
pub fn subtract(a: i32, b: i32) -> i32 {
    a - b
}

/// A type alias for a 2D point using f32 coordinates.
pub type PointF32 = PointGeneric<f32>;

/// A generic Point struct.
pub struct PointGeneric<T> {
    pub x: T,
    pub y: T,
}

/// A simple macro to create a new Point.
#[macro_export]
macro_rules! make_point {
    ($x:expr, $y:expr) => {
        $crate::Point { x: $x, y: $y }
    };
}

/// A submodule for advanced math operations.
pub mod advanced {
    /// Calculates factorial (recursive).
    /// This is not optimized.
    pub fn factorial(n: u32) -> u64 {
        if n == 0 {
            1
        } else {
            (n as u64) * factorial(n - 1)
        }
    }

    /// A nested struct within the advanced module.
    pub struct AdvancedConfig {
        pub precision: u32,
    }
}

// An item specifically to test path resolution where a struct and module share a name.
// For example, if we had `crate::ambiguous` (module) and `crate::ambiguous::ambiguous` (struct).
// This is less about a path like `crate::Struct` and more about `crate::foo::foo`.
pub mod ambiguous_module {
    /// A struct that could be ambiguous if not for full paths.
    pub struct AmbiguousStruct {
        pub data: String,
    }
}

/// Constant defined via an expression
pub const MAX_POINTS: usize = 100 * 2;

/// Function with generics
pub fn first<T>(pair: (T, T)) -> T {
    pair.0
}

/// Auto trait simulation (not a real auto trait, but for testing impls)
pub trait MyAutoTrait {}
impl MyAutoTrait for i32 {} // regular impl
impl MyAutoTrait for String {} // regular impl

/// Blanket implementation example
pub trait BlanketTrait<T> {
    fn describe(&self, item: T) -> String;
}

impl<U, T> BlanketTrait<T> for U where U: std::fmt::Debug {
    fn describe(&self, item: T) -> String where T: std::fmt::Debug {
        format!("Wrapper: {:?}, Item: {:?}", self, item)
    }
}

// Negative impl (conceptual, rustdoc JSON `is_negative` field)
// Not directly representable in stable Rust source this way for testing `is_negative`.
// We'd need to check rustdoc JSON output for a crate that legitimately uses it.
// For now, this is a placeholder comment.

// Synthetic impl (conceptual, rustdoc JSON `synthetic` field)
// These are typically generated by the compiler, e.g. for `dyn Trait`.
// Testing this requires inspecting rustdoc JSON from a crate that would generate one.
